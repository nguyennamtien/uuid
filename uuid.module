<?php
// $Id$

/**
 * @file
 * Main module functions for the uuid module.
 */

// Generic Hooks

/**
 * Implements of hook_menu().
 */
function uuid_menu() {
  $items = array();

  $items['admin/config/system/uuid'] = array(
    'title' => 'Universally Unique IDentifier',
    'description' => 'Configure automatically UUID generation settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('uuid_admin'),
    'access arguments' => array('administer uuid'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'uuid.admin.inc',
  );

  return $items;
}

/**
 * Implements of hook_permissions().
 */
function uuid_permissions() {
  return array('administer uuid');
}

// Field Hooks

/**
 * Implements hook_field_info().
 */
function uuid_field_info() {
  return array(
    'uuid' => array(
      'label' => t('Universally Unique IDentifier'),
      'description' => t('This field stores a Universally Unique IDentifier in the database'),
      'settings' => array(),
      'instance_settings' => array(),
      'default_widget' => 'hidden_value',
      'default_formatter' => 'text_default',
      'locked' => TRUE,
      'no_ui' => TRUE,
    ),
  );
}

/**
 * Implements hook_field_is_empty().
 */
function uuid_field_is_empty($item, $field) {
  return empty($item['uuid']);
}

/**
 * Implements hook_field_attach_presave().
 */
function uuid_field_attach_presave($entity_type, $entity) {

  // We only update the UUID if it is a new revision.
  if (isset($entity->revision) && $entity->revision === 1) {
    $new_uuid = uuid_uuid();
    $entity->uuid['und'][0]['uuid'] = $new_uuid;
  }
}

// Fields helper functions.

/**
 * Gets a list of fieldable entities.
 *
 * @return
 *   List of fieldable entities.
 */
function uuid_list_fieldable_entities() {
  $entities = entity_get_info();
  $entity_info = array();
  foreach ($entities as $name => $data) {

    // we only care about fieldable entities
    if (!$data['fieldable']) { 
      continue;
    }

    $entity_info[$name] = array(
      'label' => t($data['label']),
      'bundles' => array()
    );

    foreach ($data['bundles'] as $bundle => $info) {
      $label = $name;
      if (!empty($info['label'])) {
        $label = $info['label'];
      }

      $entity_info[$name]['bundles'][$bundle] = t($label);
    }
  }

  return $entity_info;
}

/**
 * Enables the UUID field for a bundle.
 *
 * @param
 *   $entity The entity the bundle belongs to.
 * @param
 *   $bundle The bundle to enable the field for.
 *
 * @return
 *   Was the field enabled?
 */
function uuid_enable_field($entity, $bundle) {

  $field_id = 'uuid';
  $field = field_info_field($field_id);
  $instance = field_info_instance($entity, $field_id, $bundle);

  if (empty($field)) {
    $field = array(
      'field_name' => 'uuid', 
      'type' => 'uuid', 
      'translatable' => FALSE,
    );
    $field = field_create_field($field);
  }

  if (empty($instance)) {
    $instance = _uuid_create_instance_array($entity, $bundle);

    try {
      return is_array(field_create_instance($instance));
    }
    catch (Exception $e) {
      drupal_set_message(t('Field creation failed: @exception', array('@exception' => $e)));
      return FALSE;
    }
  }

  // we don't care if it already exists
  return TRUE;
}

/**
 * Disables the UUID field in a bundle, but don't delete it.
 *
 * @param 
 *   $entity The entity the bundle belongs to.
 * @param
 *   $bundle The bundle to enable the field for.
 *
 * @return 
 *   Was the field disabled?
 */
function uuid_disable_field($entity, $bundle) {
  //field_delete_instance(_uuid_create_instance_array($entity, $bundle)) ?
  return TRUE; // do nothing for now
}

/**
 * Generates the field instance array.
 *
 * @param $entity
 *   The name of the entity to add the field to.
 * @param $bundle
 *  The name of the bundle to add the field to.
 *
 * @return
 *   The field instance configuration.
 */
function _uuid_create_instance_array($entity, $bundle) {
  $instance = array(
    'field_name' => 'uuid',
    'entity_type' => $entity,
    'bundle' => $bundle,
    'required' => TRUE,
    'default_value_function' => 'uuid_default_value',
    'display' => array(
      'default' => array('type' => 'hidden'),
      'teaser' => array('type' => 'hidden')
    ),
  );

  return $instance;
}

/**
 * Generates the default value.
 *
 * This is invoked as a callback by field_get_default_value().
 */
function uuid_default_value($entity_type, $entity, $field, $instance, $langcode) {
  return array(array('value' => uuid_uuid()));
}

// UUID generation handling

/**
 * Fetches information about the available UUID implementations.
 */
function uuid_info() {
  return module_invoke_all('uuid_info');
}

/**
 * Implements hook_uuid_info().
 */
function uuid_uuid_info() {
  $sources = array();

  if (function_exists('uuid_create')) {
    $sources['pecl'] = array(
      'callback' => 'uuid_pecl',
      'title' => t('PECL Extension'),
    );
  }

  if (Database::getConnection()->databaseType() == 'mysql') {
    $sources['mysql'] = array(
      'callback' => 'uuid_mysql',
      'title' => t('MySQL - SELECT UUID()'),
    );
  }

  $sources['php'] = _uuid_uuid_php_info();

  return $sources;
}

/**
 * Fetches the PHP fallback generator config.
 *
 * This is used to keep 
 */
function _uuid_uuid_php_info() {
 return array(
    'callback' => 'uuid_php',
    'title' => t('PHP Fallback'),
  );
}

/**
 * Generates an Universally Unique IDentifier (UUID).
 *
 * @return
 *   An UUID, made up of 32 hex digits and 4 hyphens.
 */
function uuid_uuid() {
  static $callback;
  if (is_null($callback)) {
    $var_name = 'uuid_generator';
    $generator = variable_get($var_name, NULL);
    if (!is_null($generator) && isset($generators[$generator])) {
      $config = $generators[$generator];
    }
    else {
      $config = _uuid_uuid_php_info();
      variable_set($var_name, 'php');
    }

    if (isset($config['include'])) {
      drupal_load($config['include']['module'], $config['include']['filename']);
    }

    $callback = $config['callback'];
  }
  return $callback();
}

/**
 * Generates a UUID v4 using PHP code.
 *
 * See http://php.net/uniqid#65879
 */
function uuid_php() {
  // The field names refer to RFC 4122 section 4.1.2.
  return sprintf('%04x%04x-%04x-%03x4-%04x-%04x%04x%04x',
    // 32 bits for "time_low".
    mt_rand(0, 65535), mt_rand(0, 65535),
    // 16 bits for "time_mid".
    mt_rand(0, 65535),
    // 12 bits before the 0100 of (version) 4 for "time_hi_and_version".
    mt_rand(0, 4095),
    bindec(substr_replace(sprintf('%016b', mt_rand(0, 65535)), '01', 6, 2)),
    // 8 bits, the last two of which (positions 6 and 7) are 01, for "clk_seq_hi_res"
    // (hence, the 2nd hex digit after the 3rd hyphen can only be 1, 5, 9 or d)
    // 8 bits for "clk_seq_low" 48 bits for "node".
    mt_rand(0, 65535), mt_rand(0, 65535), mt_rand(0, 65535)
  );
}

/**
 * Generates a UUID using MySQL's implementation.
 */
function uuid_mysql() {
  return db_query('SELECT UUID()')->fetchField();
}

/**
 * Generates a UUID using the PECL extension.
 */
function uuid_pecl() {
  return uuid_create(UUID_TYPE_DEFAULT);
}


/**
 * Ensures all content and users have UUIDs, if they are supposed to.
 */
function uuid_sync() {
  //FIXME make this work using the D7 queue system
  return;

  // Users.
  if (variable_get('uuid_automatic_for_users', FALSE)) {
    $result = db_query("SELECT uid FROM {users} WHERE uid NOT IN (SELECT uid FROM {uuid_users})");
    while ($item = db_fetch_object($result)) {
      db_query("INSERT INTO {uuid_users} (uid, uuid) VALUES(%d, '%s')", $item->uid, uuid_uuid());
    }
  }

  // Comments.
  if (variable_get('uuid_automatic_for_comments', FALSE)) {
    $result = db_query("SELECT cid FROM {comments} WHERE cid NOT IN (SELECT cid FROM {uuid_comments})");
    while ($item = db_fetch_object($result)) {
      db_query("INSERT INTO {uuid_comments} (cid, uuid) VALUES(%d, '%s')", $item->cid, uuid_uuid());
    }
  }

  $types = variable_get('uuid_automatic_for_nodes', array());

  // Remove disabled node types.
  $types = array_filter($types);
  if (!empty($types)) {
    $placeholders = db_placeholders($types, 'varchar');

    // Nodes.
    $result = db_query("SELECT nid FROM {node} WHERE type IN (" . $placeholders . ") AND nid NOT IN (SELECT nid FROM {uuid_node})", $types);
    while ($item = db_fetch_object($result)) {
      db_query("INSERT INTO {uuid_node} (nid, uuid) VALUES(%d, '%s')", $item->nid, uuid_uuid());
    }

    // Revisions.
    $result = db_query("SELECT nr.vid AS vid, nr.nid AS nid FROM {node_revisions} AS nr INNER JOIN {node} n ON nr.nid = n.nid WHERE n.type IN (" . $placeholders . ") AND nr.vid NOT IN (SELECT vid FROM {uuid_node_revisions})", $types);
    while ($item = db_fetch_object($result)) {
      db_query("INSERT INTO {uuid_node_revisions} (vid, uuid, nid) VALUES(%d, '%s', %d)", $item->vid, uuid_uuid(), $item->nid);
    }
  }

  $vids = variable_get('uuid_automatic_for_taxonomy', array());

  // Remove disabled vocabularies.
  $vids = array_filter($vids);
  if ($vids) {
    $placeholders = db_placeholders($vids, 'int');

    // Vocabularies.
    $result = db_query("SELECT v.vid FROM {vocabulary} AS v WHERE v.vid IN (" . $placeholders . ") AND NOT EXISTS (SELECT vid FROM {uuid_vocabulary} WHERE vid = v.vid)", $vids);
    while ($item = db_fetch_object($result)) {
      db_query("INSERT INTO {uuid_vocabulary} (vid, uuid) VALUES(%d, '%s')", $item->vid, uuid_uuid());
    }

    // Terms.
    $result = db_query("SELECT td.tid FROM {term_data} AS td WHERE td.vid IN (" . $placeholders . ") AND NOT EXISTS (SELECT tid FROM {uuid_term_data} WHERE tid = td.tid)", $vids);
    while ($item = db_fetch_object($result)) {
      db_query("INSERT INTO {uuid_term_data} (tid, uuid) VALUES(%d, '%s')", $item->tid, uuid_uuid());
    }
  }

  drupal_set_message(t("UUID tables have been updated."));
}


